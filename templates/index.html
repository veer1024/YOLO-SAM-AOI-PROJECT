<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>LOD 2.5 ‚Äì AOI Building Elevation</title>



<!-- Leaflet -->
<link rel="stylesheet" href="/static/vendor/leaflet/leaflet.css"/>

<!-- Leaflet Draw -->
<link rel="stylesheet" href="/static/vendor/leaflet-draw/leaflet.draw.css"/>

<!-- MapLibre GL -->
<link rel="stylesheet" href="/static/vendor/maplibre-gl/maplibre-gl.css"/>


<style>

/* Fullscreen loading overlay */
  #loadingOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 99999;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(2px);
  }

  #loadingOverlay .panel {
    background: #111;
    color: #fff;
    padding: 18px 22px;
    border-radius: 12px;
    min-width: 260px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    gap: 14px;
    align-items: center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  #loadingOverlay .spinner {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.25);
    border-top-color: rgba(255,255,255,0.95);
    animation: spin 0.9s linear infinite;
  }

  #loadingOverlay .text {
    display: flex;
    flex-direction: column;
    gap: 4px;
    line-height: 1.2;
  }

  #loadingOverlay .text .title {
    font-weight: 650;
    font-size: 14px;
  }

  #loadingOverlay .text .subtitle {
    font-size: 12px;
    opacity: 0.85;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Optional: visually disable RUN while loading */
  .is-loading {
    opacity: 0.6;
    pointer-events: none;
  }

html, body { margin:0; height:100%; }


/* 2D rotation wrapper */
#map2d-wrapper {
  position: absolute;
  inset: 0;
  overflow: hidden;
}

/* actual map */
#map2d {
  transform-origin: center center;
  transition: transform 0.1s linear;
}

#map2d, #map3d { position:absolute; inset:0; }
#map3d { display:none; }

.panel-left, .panel-right {
  position:absolute;
  top:10px;
  z-index:9999;
  background:#fff;
  padding:10px;
  border-radius:6px;
  font-family:sans-serif;
  box-shadow:0 2px 10px rgba(0,0,0,0.3);
}

.panel-left { left:50px; width:220px; }
.panel-right { right:10px; width:220px; }

.panel-left button,
.panel-right button {
  width:100%;
  margin-bottom:6px;
}

#aoiInfo {
  font-size:13px;
  margin-top:6px;
  color:#333;
}


/* Blue active tool button */
.tool-active {
  background: #2563eb !important;
  color: #fff !important;
  border: 1px solid #1d4ed8 !important;
}

/* Toast popup */
#toast {
  position: fixed;
  left: 50%;
  top: 18px;
  transform: translateX(-50%);
  background: rgba(17,17,17,0.92);
  color: #fff;
  padding: 10px 14px;
  border-radius: 10px;
  z-index: 100000;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  font-size: 13px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  display: none;
  max-width: 520px;
  line-height: 1.25;
}
#toast b { font-weight: 650; }
#toast .small { opacity: 0.85; font-size: 12px; }


/* Bigger, clearer P2P labels */
.p2p-label {
  background: rgba(255,255,255,0.96);
  border: 1px solid rgba(0,0,0,0.30);
  border-radius: 10px;
  padding: 8px 10px;
  font-size: 13px;
  line-height: 1.25;
  box-shadow: 0 10px 28px rgba(0,0,0,0.22);
  min-width: 140px;
  max-width: 220px;
  white-space: normal;
}

/* Directional placement around the point (Leaflet divIcon) */
.p2p-ne { transform: translate(10px, -110%); }
.p2p-nw { transform: translate(calc(-100% - 10px), -110%); }
.p2p-se { transform: translate(10px, 10px); }
.p2p-sw { transform: translate(calc(-100% - 10px), 10px); }

/* Optional: make the A/B badge look nicer */
.p2p-badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 999px;
  background: rgba(37,99,235,0.12);
  border: 1px solid rgba(37,99,235,0.35);
  margin-bottom: 6px;
  font-weight: 650;
}
.p2p-small { opacity: 0.85; font-size: 12px; }


.pinfo-close {
  position: absolute;
  top: 6px;
  right: 8px;
  border: none;
  background: transparent;
  cursor: pointer;
  font-size: 16px;
  line-height: 16px;
  opacity: 0.7;
}
.pinfo-close:hover { opacity: 1; }

.pinfo-wrap { position: relative; }


.import-box{
  border:2px dashed #cbd5e1;
  border-radius:10px;
  padding:12px;
  background:#f8fafc;
}
.import-hint{ font-size:13px; color:#334155; text-align:center; }
.import-status{ margin:10px 0 6px; font-size:12px; }
.import-status .ok{ color:#16a34a; }
.import-status .bad{ color:#dc2626; }
#importLoadBtn:disabled{ opacity:0.5; cursor:not-allowed; }

</style>
</head>

<body>




  <div id="toast"></div>
<div id="loadingOverlay" aria-live="polite" aria-busy="true">
  <div class="panel">
    <div class="spinner"></div>
    <div class="text">
      <div class="title">Running model‚Ä¶</div>
      <div class="subtitle">Please wait while 3D buildings are generated</div>
    </div>
  </div>

</div>
<!-- LEFT PANEL -->
<div class="panel-left">
  <!-- <button onclick="enableAOISelection()">üü® Select AOI</button>
  <button id="runBtn" onclick="runAOIML()">üöÄ Run ML</button>
  <button onclick="toggleTiles()">üü™ Toggle Tiles</button> -->
  <button id="p2pBtn" onclick="toggleP2PDistance()">üìè P2P Distance</button>
  <button onclick="toggle3DStyle()">üó∫ View: Satellite / Shadowmap</button>

  <!-- <div id="aoiInfo">AOI: not selected</div> -->

  <hr/>
<!-- <b>Rotate 2D Map</b><br/>

<input
  type="range"
  min="-180"
  max="180"
  value="0"
  id="rotationSlider"
  style="width:100%;"
  oninput="rotateMap2D(this.value)"
/> -->

<!-- <div style="font-size:12px; text-align:center;">
  <span id="rotationValue">0¬∞</span>
</div>

<button onclick="resetRotation()">Reset Rotation</button> -->

</div>

<!-- RIGHT PANEL -->
<div class="panel-right">
  <button onclick="toggle3DView()">üß≠ Toggle 3D / Top</button>
  <button onclick="toggleImportPanel()">üì• Import (GeoJSON / GLB)</button>
  <!-- <button onclick="enableFeedbackMode()">üß† Improve Model</button>
  <button onclick="enableYOLOFeedback()">üì¶ Improve Detector (YOLO)</button> -->
  <!-- <button onclick="enableManualBuildMode()">üèó Manual Build Map</button>
  <button onclick="saveManualBuild()">üíæ Save Manual Map</button> -->
  <button onclick="exportPrebuild('geojson')">‚¨á Export GeoJSON</button>
  <button onclick="exportPrebuild('glb')">‚¨á Export GLB</button>

  <button onclick="clearAll()">‚ôª Clear</button>

</div>

<!-- EXPORT PANEL -->
<div id="exportPanel" class="panel-right" style="top:430px; display:none;">
  <b>Export</b><br/><br/>

  <button id="dlGeojsonBtn">‚¨á GeoJSON</button>
  <button id="dlGlbBtn">‚¨á GLB</button>

  <hr/>

  <button onclick="exportMapImage('png')">üñº Export PNG (view)</button>
  <button onclick="exportMapImage('jpg')">üñº Export JPG (view)</button>

  <hr/>

  <button id="dlTiffBtn">üó∫ Export GeoTIFF (AOI)</button>
</div>


<!-- IMPORT PANEL -->
<div id="importPanel" class="panel-right" style="top:520px; display:none;">
  <b>Import</b><br/><br/>

  <div id="dropZone" class="import-box">
    <div class="import-hint">
      Drag & drop <b>.geojson</b> + <b>.glb</b><br/>
      <small>Exactly one of each (max 2 files)</small>
    </div>

    <input id="importFileInput" type="file" multiple
      accept=".geojson,.glb,application/geo+json,model/gltf-binary"
      style="width:100%;"
    />

    <div class="import-status">
      <div id="geojsonStatus" class="bad">‚ùå GeoJSON not loaded</div>
      <div id="glbStatus" class="bad">‚ùå GLB not loaded</div>
    </div>

    <button id="importLoadBtn" onclick="runImportUpload()" disabled>‚¨Ü Upload & Load</button>
    <button onclick="clearImported()">üßπ Clear Imported</button>
  </div>
</div>


<!-- GLB VIEWER (overlay) -->
<div id="glbViewerWrap" style="
  position: fixed;
  inset: 0;
  display: none;
  z-index: 100001;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(2px);
">
  <div style="
    position:absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    width: min(980px, 92vw);
    height: min(680px, 86vh);
    background: #111;
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 18px 60px rgba(0,0,0,0.45);
  ">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; color:#fff; font-family:system-ui;">
      <b>GLB Viewer</b>
      <button onclick="closeGlbViewer()" style="cursor:pointer; border:none; background:#333; color:#fff; padding:6px 10px; border-radius:10px;">‚úï Close</button>
    </div>
    <div style="height: calc(100% - 44px); background:#000;">
      <!-- <model-viewer id="glbViewer"
        style="width:100%; height:100%;"
        src=""
        camera-controls
        auto-rotate
        exposure="1.0"
        shadow-intensity="0.7"
        ar
      ></model-viewer> -->
      <model-viewer id="glbViewer"
        style="width:100%; height:100%;"
        src=""
        camera-controls
        auto-rotate
        exposure="1.4"
        shadow-intensity="1.0"
        environment-image="neutral"
        tone-mapping="aces"
      ></model-viewer>
    </div>
  </div>
</div>


<!-- FEEDBACK PANEL -->
<div id="feedbackPanel" class="panel-right" style="top:160px; display:none;">
  <b>Improve Model</b><br/><br/>

  <label>
    <input type="radio" name="fbType" value="missing_building" checked>
    Missing Building
  </label><br/>

  <label>
    <input type="radio" name="fbType" value="wrong_geometry">
    Wrong Geometry
  </label><br/>

  <button id="addPolyBtn" onclick="finalizeAndStartNextPolygon()" style="display:none" disabled>
  ‚ûï Add another polygon (WRONG GEOMETRY)
</button><!-- <br/> -->
<div id="polyCount" style="display:none; font-size:12px; margin:6px 0; opacity:0.8;">
  Polygons ready: 0
</div>
<br/>

  <label>
    <input type="radio" name="fbType" value="not_a_building">
    üö´ Not a Building
  </label><br/><br/>

  <small>
  ‚Ä¢ Click to draw building footprint (polygon)<br/>
  ‚Ä¢ Double-click to finish
</small><br/><br/>



  <button onclick="submitFeedback()">‚úÖ Submit</button>
  <button onclick="cancelFeedback()">‚ùå Cancel</button>
</div>


<!-- YOLO FEEDBACK PANEL -->
<div id="yoloPanel" class="panel-right" style="top:300px; display:none;">
  <b>Improve YOLO</b><br/><br/>

  <label>
    <input type="radio" name="yoloType" value="missing_building" checked>
    Missing Building
  </label><br/>

  <label>
    <input type="radio" name="yoloType" value="not_a_building">
    üö´ Not a Building
  </label><br/><br/>

  <small>
  ‚Ä¢ Click to draw roof polygon<br/>
  ‚Ä¢ Auto-closes after 3 points<br/>
  ‚Ä¢ One polygon at a time
</small><br/><br/>

  <button onclick="submitYOLOFeedback()">‚úÖ Submit</button>
  <button onclick="cancelYOLOFeedback()">‚ùå Cancel</button>
</div>


<div id="map2d-wrapper">
  <div id="map2d"></div>
</div>


<div id="map3d"></div>

<!-- LIBS -->


<!-- Leaflet -->
<script src="/static/vendor/leaflet/leaflet.js"></script>

<!-- Leaflet Draw -->
<script src="/static/vendor/leaflet-draw/leaflet.draw.js"></script>

<!-- MapLibre GL -->
<script src="/static/vendor/maplibre-gl/maplibre-gl.js"></script>

<!-- Geometry Util -->
<script src="/static/vendor/leaflet-geometryutil/leaflet.geometryutil.js"></script>

<script type="module" src="/static/vendor/model-viewer/model-viewer.min.js"></script>


<script>

let manualBuildMode = false;
let manualStage = null; // "building" | "shadow"
let manualBuildings = [];

let currentBuildingLayer = null;
let currentShadowLayer = null;

let manualDrawControl = null;


/* export feature constants */

let lastOutputs = {
  geojsonUrl: null,
  glbUrl: null,
  tiffUrl: null  // will be set if backend endpoint exists
};



// Map instances (declared early to avoid TDZ errors)
let map2d = null;
let map3d = null;
function showExportPanel(data) {
  // data.geojson = "output/buildings_xxx.geojson"
  // data.glb    = "output/aoi_buildings_xxx.glb"

  lastOutputs.geojsonUrl = data.geojson ? ("/ml/" + data.geojson) : null;
  lastOutputs.glbUrl     = data.glb ? ("/ml/" + data.glb) : null;

  // GeoTIFF export will require backend. We'll call /export_aoi_tif using lastAOIBounds
  lastOutputs.tiffUrl = "/export_aoi_tif"; 

  const panel = document.getElementById("exportPanel");
  if (panel) panel.style.display = "block";

  // Wire GeoJSON
  const gjBtn = document.getElementById("dlGeojsonBtn");
  if (gjBtn) {
    gjBtn.disabled = !lastOutputs.geojsonUrl;
    gjBtn.onclick = () => downloadUrl(lastOutputs.geojsonUrl, "buildings.geojson");
  }

  // Wire GLB
  const glbBtn = document.getElementById("dlGlbBtn");
  if (glbBtn) {
    glbBtn.disabled = !lastOutputs.glbUrl;
    glbBtn.onclick = () => downloadUrl(lastOutputs.glbUrl, "buildings.glb");
  }

  // Wire GeoTIFF (posts AOI bounds)
  const tifBtn = document.getElementById("dlTiffBtn");
  if (tifBtn) {
    tifBtn.disabled = !lastAOIBounds;
    tifBtn.onclick = () => downloadAOIGeoTiff();
  }
}

function hideExportPanel() {
  const panel = document.getElementById("exportPanel");
  if (panel) panel.style.display = "none";
}

function downloadUrl(url, filename) {
  const a = document.createElement("a");
  a.href = url;
  a.download = filename || "";
  document.body.appendChild(a);
  a.click();
  a.remove();
}


function exportMapImage(format = "png") {
  // format: "png" or "jpg"

  // Prefer exporting current visible view
  const is3dVisible = document.getElementById("map3d").style.display !== "none";

  if (is3dVisible) {
    exportMapboxCanvas(format);
  } else {
    exportLeafletCanvas(format); // best-effort (tiles are not always CORS friendly)
  }
}

function exportMapboxCanvas(format) {
  const mime = (format === "jpg") ? "image/jpeg" : "image/png";

  // Ensure the map has finished rendering the current frame
  map3d.once("idle", () => {

    if (lastAOIBounds) flyToAOI(lastAOIBounds);
  hideLoading();
  enableMapboxInteraction(map3d); 

    try {
      const canvas = map3d.getCanvas();
      const dataUrl = canvas.toDataURL(mime, 0.95);
      const name = format === "jpg" ? "map_view.jpg" : "map_view.png";
      downloadUrl(dataUrl, name);
    } catch (e) {
      console.error(e);
      alert("Export failed. If you see a security error, your tiles are blocking canvas export (CORS).");
    }
  });

  // In case it‚Äôs already idle, kick a repaint so 'idle' fires consistently
  map3d.triggerRepaint();
}



async function downloadAOIGeoTiff() {
  if (!lastAOIBounds) {
    alert("Draw AOI first.");
    return;
  }

  try {
    const res = await fetch("/export_aoi_tif", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ bounds: lastAOIBounds })
    });

    if (!res.ok) {
      const t = await res.text();
      throw new Error(t);
    }

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    downloadUrl(url, "aoi.tif");
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error(e);
    alert("GeoTIFF export failed (backend endpoint missing or error).");
  }
}


function toggleImportPanel() {
  clearAll();
  const panel = document.getElementById("importPanel");
  if (!panel) return;

  const isOpen = panel.style.display !== "none";

  // close it
  if (isOpen) {
    panel.style.display = "none";
    return;
  }

  // open it
  panel.style.display = "block";

  // optional: close other panels so UI doesn‚Äôt overlap
  try { document.getElementById("feedbackPanel").style.display = "none"; } catch(e){}
  try { document.getElementById("yoloPanel").style.display = "none"; } catch(e){}

  // ensure status text/button state is correct when opening
  try { updateImportUI(); } catch(e){}
}


/* import glb, geojson */

/* import glb, geojson */

// -----------------------
// IMPORT STATE (strict)
// -----------------------
let _importFiles = []; // File[]
let _importGeoFile = null; // File
let _importGlbFile = null; // File
let _importedGeojsonPath = null;
let _importedGlbPath = null;

function updateImportUI() {
  const geoEl = document.getElementById("geojsonStatus");
  const glbEl = document.getElementById("glbStatus");
  const loadBtn = document.getElementById("importLoadBtn");

  if (geoEl) {
    geoEl.textContent = _importGeoFile ? `‚úî ${_importGeoFile.name}` : "‚ùå GeoJSON not loaded";
    geoEl.className = _importGeoFile ? "ok" : "bad";
  }
  if (glbEl) {
    glbEl.textContent = _importGlbFile ? `‚úî ${_importGlbFile.name}` : "‚ùå GLB not loaded";
    glbEl.className = _importGlbFile ? "ok" : "bad";
  }

  if (loadBtn) loadBtn.disabled = !(_importGeoFile && _importGlbFile);
}

function clearImported() {
  _importFiles = [];
  _importGeoFile = null;
  _importGlbFile = null;
  _importedGeojsonPath = null;
  _importedGlbPath = null;

  const inp = document.getElementById("importFileInput");
  if (inp) inp.value = "";



  updateImportUI();
  showToast(`<b>üßπ Cleared import selection</b>`, 1500);
}

function validateAndSetImportFiles(files) {
  const picked = Array.from(files || []);
  if (picked.length === 0) return;

  for (const f of picked) {
    const n = (f.name || "").toLowerCase();

    if (n.endsWith(".geojson")) {
      _importGeoFile = f;
    } else if (n.endsWith(".glb")) {
      _importGlbFile = f;
    } else {
      showToast(
        `<b>‚ùå Unsupported file</b><div class="small">${f.name}</div>`,
        2500
      );
    }
  }

  // Enforce "exactly one of each"
  if (_importGeoFile && _importGlbFile) {
    _importFiles = [_importGeoFile, _importGlbFile];
    showToast(
      `<b>üì• Ready to import</b><div class="small">${_importGeoFile.name} + ${_importGlbFile.name}</div>`,
      2200
    );
  } else {
    _importFiles = [];
  }

  updateImportUI();
}


// Dropzone wiring
(function wireDropZone(){
  const dz = document.getElementById("dropZone");
  const inp = document.getElementById("importFileInput");
  if (!dz || !inp) return;

  dz.addEventListener("dragover", (e) => {
    e.preventDefault();
    dz.style.background = "#f0f7ff";
    dz.style.borderColor = "#2563eb";
  });

  dz.addEventListener("dragleave", () => {
    dz.style.background = "#f8fafc";
    dz.style.borderColor = "#cbd5e1";
  });

  dz.addEventListener("drop", (e) => {
    e.preventDefault();
    dz.style.background = "#f8fafc";
    dz.style.borderColor = "#cbd5e1";
    validateAndSetImportFiles(e.dataTransfer.files);
  });

  inp.addEventListener("change", (e) => {
    validateAndSetImportFiles(e.target.files);
  });

  updateImportUI(); // init state on load
})();


async function fitMapToGeoJSONPath(path) {
  try {
    const res = await fetch("/ml/" + path);
    const gj = await res.json();

    let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

    function scan(coords) {
      coords.forEach(c => {
        if (typeof c[0] === "number") {
          minLng = Math.min(minLng, c[0]);
          minLat = Math.min(minLat, c[1]);
          maxLng = Math.max(maxLng, c[0]);
          maxLat = Math.max(maxLat, c[1]);
        } else scan(c);
      });
    }

    (gj.features || []).forEach(f => {
      if (f?.geometry?.coordinates) scan(f.geometry.coordinates);
    });

    if (!isFinite(minLng)) return;

    map3d.fitBounds([[minLng, minLat], [maxLng, maxLat]], {
      padding: 80,
      duration: 900,
      maxZoom: 19,
      pitch: (viewMode === "3d") ? 65 : 0,
      bearing: (viewMode === "3d") ? -20 : 0
    });
  } catch (e) {
    console.warn("fitMapToGeoJSONPath failed:", e);
  }
}


async function runImportUpload() {
  if (!_importFiles || _importFiles.length === 0) {
    alert("Select or drop .geojson / .glb first.");
    return;
  }

  const fd = new FormData();
  for (const f of _importFiles) fd.append("files", f);

  try {
    showLoading("Uploading imported files‚Ä¶");

    const res = await fetch("/import_upload", {
      method: "POST",
      body: fd
    });

    const data = await res.json();
    if (!res.ok) {
      hideLoading();
      throw new Error(data.error || "Import upload failed");
    }

    // Backend returns { geojson: "imports/...geojson", glb: "imports/...glb" }
    _importedGeojsonPath = data.geojson || null;
    _importedGlbPath = data.glb || null;

    // If geojson exists: load into MapLibre like normal pipeline output
    if (_importedGeojsonPath) {
      show3DView();
      showLoading("Loading imported GeoJSON into 3D‚Ä¶");
      loadBuildings(_importedGeojsonPath);     // your existing function expects relative path
      apply3DStyleMode();

      map3d.once("idle", async () => {
        // ‚úÖ zoom to imported geojson extent (not AOI, not CENTER)
        if (_importedGeojsonPath) {
          await fitMapToGeoJSONPath(_importedGeojsonPath);
        }
        hideLoading();
        showToast(`<b>‚úÖ Imported GeoJSON loaded</b>`, 1800);
      });
    } else {
      hideLoading();
    }

    // If GLB exists: open viewer
    if (_importedGlbPath) {
      openGlbViewer("/ml/" + _importedGlbPath);
    }

    // Optional: show export panel so user can re-download easily
    showExportPanel({
      geojson: _importedGeojsonPath,
      glb: _importedGlbPath
    });

  } catch (e) {
    console.error(e);
    hideLoading();
    alert("Import failed: " + e.message);
  }
}

function openGlbViewer(url) {
  const wrap = document.getElementById("glbViewerWrap");
  const viewer = document.getElementById("glbViewer");
  if (!wrap || !viewer) return;
  viewer.setAttribute("src", url);
  wrap.style.display = "block";
}

function closeGlbViewer() {
  const wrap = document.getElementById("glbViewerWrap");
  const viewer = document.getElementById("glbViewer");
  if (viewer) viewer.setAttribute("src", "");
  if (wrap) wrap.style.display = "none";
}


function startManualPolygonDraw(color = "#2563eb") {
  if (manualDrawControl) {
    try { manualDrawControl.disable(); } catch(e){}
    manualDrawControl = null;
  }

  manualDrawControl = new L.Draw.Polygon(map2d, {
    allowIntersection: false,
    showArea: true,
    shapeOptions: { color }
  });

  manualDrawControl.enable();
}



function enableManualBuildMode() {
  //cancelAllModes(); // reuse your existing cleanup if any

  manualBuildMode = true;
  manualStage = "building";
  manualBuildings = [];

  showToast("<b>Manual Build Mode</b><br/>Draw BUILDING footprint (min 3 points)");

  manualBuildMode = true;
manualStage = "building";
manualBuildings = [];

showToast("<b>Manual Build Mode</b><br/>Draw BUILDING footprint (min 3 points)");
startManualPolygonDraw("#2563eb"); // blue = building


}

function isValidPolygon(layer) {
  const latlngs = layer.getLatLngs()[0];
  return latlngs && latlngs.length >= 3;
}



function saveManualPair() {
  const buildingGeoJSON = currentBuildingLayer.toGeoJSON().geometry;
  const shadowGeoJSON   = currentShadowLayer.toGeoJSON().geometry;

  manualBuildings.push({
    id: "bldg_" + (manualBuildings.length + 1),
    building: buildingGeoJSON,
    shadow: shadowGeoJSON
  });

  showToast(`‚úÖ Building ${manualBuildings.length} saved`);

  currentBuildingLayer = null;
  currentShadowLayer = null;

  manualStage = "building";
startManualPolygonDraw("#2563eb"); // next building
  }


async function saveManualBuild() {
  if (manualBuildings.length === 0) {
    alert("No buildings drawn.");
    return;
  }

  const res = await fetch("/manual_build/save", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      crs: "EPSG:4326",
      buildings: manualBuildings
    })
  });

  if (!res.ok) {
    alert("Save failed");
    return;
  }

  const data = await res.json();
  showExportPanel(data); // reuse your export UI
  showToast("üèó Manual map saved & exported");
}




/* loader for ml run =============== */

function disableMapInteraction(map) {
  if (!map) return;
  try {
    map.dragging.disable();
    map.scrollWheelZoom.disable();
    map.doubleClickZoom.disable();
    map.boxZoom.disable();
    map.keyboard.disable();
    map.touchZoom.disable();
    if (map.tap) map.tap.disable();
    map._container.style.cursor = "wait";
  } catch (e) {
    console.warn("Failed to disable map interaction:", e);
  }
}

function enableMapInteraction(map) {
  if (!map) return;
  try {
    map.dragging.enable();
    map.scrollWheelZoom.enable();
    map.doubleClickZoom.enable();
    map.boxZoom.enable();
    map.keyboard.enable();
    map.touchZoom.enable();
    if (map.tap) map.tap.enable();
    map._container.style.cursor = "";
  } catch (e) {
    console.warn("Failed to enable map interaction:", e);
  }
}

 let _modelRunning = false;

  function showLoading(message) {
    const overlay = document.getElementById("loadingOverlay");
    if (!overlay) return;

    if (message) {
      const subtitle = overlay.querySelector(".subtitle");
      if (subtitle) subtitle.textContent = message;
    }

    overlay.style.display = "flex";
    _modelRunning = true;

    // Disable UI controls if you have a RUN button
    const runBtn = document.getElementById("runBtn"); // <-- change id if your button differs
    if (runBtn) runBtn.classList.add("is-loading");

    // Disable map
    disableMapInteraction(map2d);
    disableMapboxInteraction(map3d);
  }

  function hideLoading() {
    const overlay = document.getElementById("loadingOverlay");
    if (overlay) overlay.style.display = "none";
    _modelRunning = false;

    const runBtn = document.getElementById("runBtn"); // <-- change id if your button differs
    if (runBtn) runBtn.classList.remove("is-loading");

    enableMapInteraction(map2d);
    enableMapboxInteraction(map3d);
  }

  // Safety: if page reloads mid-run
  window.addEventListener("beforeunload", () => {
    if (_modelRunning) return "";
  });

/* ================= CONFIG ================= */

//mapboxgl.accessToken = "pk.eyJ1IjoidmVlcjEwMjQiLCJhIjoiY21pdTduMnJrMGg5djNxcjRydGp4czc3eiJ9.1qqR0xid2EBNBFNb4TmkMg";

let feedbackPolygons = [];     // array of GeoJSON Polygon
let currentPolygonLayer = null;
let viewStyleMode = "satellite"; // "satellite" | "shadowmap"


const CENTER = [89.5348056, 28.8863333];


let hoveredFeatureId = null;
const RASTER_BOUNDS = [
  89.5145926,  // West
  28.8721667,  // South
  89.5550185,  // East
  28.9005000   // North
];

/* ================= STATE ================= */

let aoiRect = null;
let modelLoaded = false;
let viewMode = "3d";

let feedbackMode = false;
let feedbackPoints = [];
let selectedOriginalGeometry = null;
let highlightedFeatureId = null;

let prebuildActive = false;        // üîë is prebuild currently shown
let prebuildLoadedOnce = false;   // üîë optional, for future use

const aoiLayer = new L.FeatureGroup();
const feedbackLayer = new L.FeatureGroup();
const tileDebugLayer = L.layerGroup();
let aoiDrawActive = false;


 let yoloMode = false;
let yoloPoints = [];        // [[lng,lat], ...]
let yoloPreviewLayer = null;
let yoloRectLayer = null;
let lastAOIBounds = null;   // [west,south,east,north] in EPSG:4326


 function clearAllDrawControls() {
  try { map2d.removeControl(drawControl); } catch(e){}
  
}

/* ================= tile function ======== */

function drawTiles(tileBoundsList) {
  tileDebugLayer.clearLayers();

  tileBoundsList.forEach((b, i) => {
    const rect = L.rectangle(
      [[b[1], b[0]], [b[3], b[2]]], // southWest, northEast
      {
        color: "#FF00FF",
        weight: 1,
        fillOpacity: 0.05,
        dashArray: "4,4"
      }
    );

    rect.bindTooltip(`Tile ${i + 1}`, { permanent: false });
    tileDebugLayer.addLayer(rect);
  });
}


let tilesVisible = true;

function toggleTiles(){
  tilesVisible = !tilesVisible;
  if(tilesVisible){
    map2d.addLayer(tileDebugLayer);
  } else {
    map2d.removeLayer(tileDebugLayer);
  }
}

 // WRONG GEOMETRY HELPER FUNCTIONS 
function setAddPolyEnabled(enabled) {
  const btn = document.getElementById("addPolyBtn");
  if (btn) btn.disabled = !enabled;
}

function updatePolyCount() {
  const el = document.getElementById("polyCount");
  if (el) el.textContent = `Polygons ready: ${feedbackPolygons.length}`;
}

function getCurrentDrawnPolygonIfReady() {
  // only meaningful when we already formed a polygon preview
  if (feedbackPoints.length < 3) return null;

  // Close polygon with first point
  const ring = [...feedbackPoints, feedbackPoints[0]];
  return { type: "Polygon", coordinates: [ring] };
}

function redrawCurrentPolygonPreview() {
  // remove old preview polygon if any
  if (currentPolygonLayer) {
    try { feedbackLayer.removeLayer(currentPolygonLayer); } catch(e){}
    currentPolygonLayer = null;
  }

  if (feedbackPoints.length >= 3) {
    const poly = getCurrentDrawnPolygonIfReady();
    currentPolygonLayer = L.polygon(
      poly.coordinates[0].map(p => [p[1], p[0]]),
      { color: "orange", fillOpacity: 0.25 }
    ).addTo(feedbackLayer);
  }
}


function redrawYOLOPreview() {
  if (yoloPreviewLayer) {
    feedbackLayer.removeLayer(yoloPreviewLayer);
    yoloPreviewLayer = null;
  }

  if (yoloPoints.length >= 2) {
    const ring = [...yoloPoints, yoloPoints[0]];

    yoloPreviewLayer = L.polygon(
      ring.map(p => [p[1], p[0]]),
      {
        color: "deepskyblue",
        fillOpacity: 0.25,
        weight: 2
      }
    ).addTo(feedbackLayer);
  }
}

function finalizeAndStartNextPolygon() {
  const type = document.querySelector('input[name="fbType"]:checked').value;
  if (type !== "wrong_geometry") return;

  const poly = getCurrentDrawnPolygonIfReady();
  if (!poly) {
    alert("Draw at least 3 points first.");
    return;
  }


  // Save polygon to array
  feedbackPolygons.push(poly);
  updatePolyCount();

  // Make the saved polygon look ‚Äúlocked‚Äù (darker)
  L.polygon(
    poly.coordinates[0].map(p => [p[1], p[0]]),
    { color: "orange", fillOpacity: 0.35, weight: 2 }
  ).addTo(feedbackLayer);

  // Reset current drawing points
  feedbackPoints = [];

  // Remove preview polygon (so user starts fresh)
  if (currentPolygonLayer) {
    try { feedbackLayer.removeLayer(currentPolygonLayer); } catch(e){}
    currentPolygonLayer = null;
  }

  // Disable until 3 points again
  setAddPolyEnabled(false);

  
// remove all temporary markers & preview only (but keep locked polygons)
feedbackLayer.eachLayer(layer => {
  // remove only CircleMarkers + currentPolygonLayer
  if (layer instanceof L.CircleMarker) feedbackLayer.removeLayer(layer);
});

}



/* ================= MAP 2D ================= */

// map2d =  L.map("map2d").setView([CENTER[1], CENTER[0]], 19);
// L.tileLayer("/tiles/{z}/{x}/{y}.png", { maxZoom:20 }).addTo(map2d);

map2d =  L.map("map2d");

const tiles2d = L.tileLayer("/tiles/{z}/{x}/{y}.png", { maxZoom: 20 }).addTo(map2d);

// ================= MANUAL BUILD DRAW HANDLER =================

map2d.on(L.Draw.Event.CREATED, function (e) {

  // Ignore if not manual build
  if (!manualBuildMode) return;

  const layer = e.layer;

  if (!isValidPolygon(layer)) {
    showToast("‚ùå Polygon needs at least 3 points");
    return;
  }

  if (manualStage === "building") {
  currentBuildingLayer = layer;
  currentBuildingLayer.addTo(map2d);

  manualStage = "shadow";
  showToast("Now draw SHADOW polygon for this building");

  startManualPolygonDraw("#dc2626"); // red = shadow
  return;
}

  if (manualStage === "shadow") {
    currentShadowLayer = layer;
    currentShadowLayer.addTo(map2d);

    saveManualPair();
    return;
  }
});


tiles2d.on("loading", () => console.log("2D tiles loading..."));
tiles2d.on("load", () => console.log("2D tiles loaded"));
tiles2d.on("tileerror", (e) => console.log("2D tileerror:", e.coords, e.error));

// Force correct sizing + zoom to raster area
setTimeout(() => {
  map2d.invalidateSize(true);
  map2d.fitBounds(
    [
      [RASTER_BOUNDS[1], RASTER_BOUNDS[0]], // SW [lat,lng]
      [RASTER_BOUNDS[3], RASTER_BOUNDS[2]]  // NE [lat,lng]
    ],
    { padding: [20, 20] }
  );
}, 150);


map2d.addLayer(aoiLayer);
map2d.addLayer(feedbackLayer);
map2d.addLayer(tileDebugLayer);


/* ================= MAP 2D rotation ================= */

let currentRotation = 0;

function rotateMap2D(deg){
  currentRotation = deg;
  document.getElementById("map2d").style.transform =
    `rotate(${deg}deg)`;

  document.getElementById("rotationValue").innerText = `${deg}¬∞`;

  if(deg != 0){
  document.getElementById("aoiInfo").innerHTML =
    `AOI: not selected<br/><small>‚ö† Map rotated (${deg}¬∞)</small>`;
}


  // üîë Important: fix mouse interaction after transform
  map2d.invalidateSize();


}

function resetRotation(){
  rotateMap2D(0);
  document.getElementById("rotationSlider").value = 0;
}


/* =================== HELPER ================= */

function setLastAOIFromRect() {
  if (!aoiRect) return null;
  const b = aoiRect.getBounds();
  lastAOIBounds = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()];
  return lastAOIBounds;
}

function flyToAOI(bounds) {
  // bounds = [west, south, east, north]
  if (!bounds) return;

  // IMPORTANT: call only when map3d is visible and resized
  map3d.fitBounds(
    [
      [bounds[0], bounds[1]], // SW (lng, lat)
      [bounds[2], bounds[3]]  // NE (lng, lat)
    ],
    {
      padding: 80,
      duration: 800,
      pitch: (viewMode === "3d") ? 65 : 0,
      bearing: (viewMode === "3d") ? -20 : 0
    }
  );
}

function resetPolygonState() {
   feedbackPoints = [];
  feedbackPolygons = [];
  currentPolygonLayer = null;
  updatePolyCount();
  setAddPolyEnabled(false);
}


/* ================= AOI DRAW ================= */

const drawControl = new L.Control.Draw({
  draw: {
    rectangle: { shapeOptions:{ color:"yellow", fillOpacity:0.2 } },
    polygon:false, polyline:false, circle:false, marker:false, circlemarker:false
  },
  edit: { featureGroup: aoiLayer, remove:true }
});





function enableAOISelection(){
  if (currentRotation !== 0) {
    alert("Map rotation will be reset for AOI selection.");
    resetRotation();
  }

  clearAllDrawControls();
  show2DView();

  if (!aoiDrawActive) {
    map2d.addControl(drawControl);
    aoiDrawActive = true;
  }
}

function disableMapboxInteraction(m) {
  if (!m) return;
  try {
    m.boxZoom.disable();
    m.doubleClickZoom.disable();
    m.dragPan.disable();
    m.dragRotate.disable();
    m.keyboard.disable();
    m.scrollZoom.disable();
    m.touchZoomRotate.disable();
    m.getCanvas().style.cursor = "wait";
  } catch (e) {
    console.warn("Failed to disable mapbox interaction:", e);
  }
}

function enableMapboxInteraction(m) {
  if (!m) return;
  try {
    m.boxZoom.enable();
    m.doubleClickZoom.enable();
    m.dragPan.enable();
    m.dragRotate.enable();
    m.keyboard.enable();
    m.scrollZoom.enable();
    m.touchZoomRotate.enable();
    m.getCanvas().style.cursor = "";
  } catch (e) {
    console.warn("Failed to enable mapbox interaction:", e);
  }
}

map2d.on(L.Draw.Event.CREATED, e => {

  // ===== YOLO MODE =====
  if (yoloMode) {
  if (e.layerType !== "rectangle") return;

  feedbackLayer.clearLayers();
  yoloRectLayer = e.layer;  // rename later if you want
  feedbackLayer.addLayer(yoloRectLayer);
  return;
}

  // ===== AOI MODE =====
  if (e.layerType === "rectangle") {
    aoiLayer.clearLayers();
    aoiRect = e.layer;
    setLastAOIFromRect();
    aoiLayer.addLayer(aoiRect);

    aoiDrawActive = false;
    map2d.removeControl(drawControl);

    const area = L.GeometryUtil.geodesicArea(
      aoiRect.getLatLngs()[0]
    );

    document.getElementById("aoiInfo").innerHTML =
      `AOI Area: ${area.toFixed(0)} m¬≤`;
  }
});


/* ================= MAP 3D ================= */



// map3d =  new mapboxgl.Map({
//   container: "map3d",
//   style: {
//     version: 8,
//     glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
//     sources: {},
//     layers: []
//   },
//   center: CENTER,
//   zoom: 19,
//   pitch: 65,
//   bearing: -20,
//   antialias: true,

//   preserveDrawingBuffer: true
// });

map3d =  new maplibregl.Map({
  container: "map3d",
  style: {
    version: 8,
    sources: {},
    layers: []
  },
  center: CENTER,
  zoom: 19,
  pitch: 65,
  bearing: -20,
  antialias: true,
  preserveDrawingBuffer: true
});


/* ============= BUILDING HOVER ================== */

const hoverPopup = new maplibregl.Popup({
  closeButton: false,
  closeOnClick: false,
  offset: 10
});


/* ================= VIEW ================= */




function show2DView(){
  document.getElementById("map3d").style.display="none";
  document.getElementById("map2d-wrapper").style.display="block";
  setTimeout(()=>map2d.invalidateSize(),200);
}

function show3DView(){
  document.getElementById("map2d-wrapper").style.display="none";
  document.getElementById("map3d").style.display="block";

  // Mapbox needs a resize AFTER it's visible
  setTimeout(() => {
    map3d.resize();
    if (lastAOIBounds) flyToAOI(lastAOIBounds);
  }, 50);
}


function toggle3DView(){
  if(!modelLoaded) return;

  const c = map3d.getCenter();
  const z = map3d.getZoom();

  const toTop = (viewMode === "3d");
  map3d.easeTo({
    center: c,
    zoom: z,
    pitch: toTop ? 0 : 65,
    bearing: toTop ? 0 : -20,
    duration: 500
  });

  viewMode = toTop ? "top" : "3d";

  // Keep AOI framed
  setTimeout(() => {
    if (lastAOIBounds) flyToAOI(lastAOIBounds);
  }, 550);
}


/* ================= RUN ML ================= */

async function runAOIML(){
  if(!aoiRect){
    alert("‚ùå Draw AOI first");
    return;
  }

  if (_modelRunning) return; // prevent double clicks

  try {
    showLoading("Submitting AOI and running model‚Ä¶");

    const b = aoiRect.getBounds();

    const res = await fetch("/run_aoi_ml",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body:JSON.stringify({
        bounds:[b.getWest(),b.getSouth(),b.getEast(),b.getNorth()]
      })
    });

    const data = await res.json();

    if(!data.geojson){
      hideLoading();
      hideExportPanel();
      alert("‚ö† No buildings detected in this AOI.\nTry a larger area or improve YOLO.");
      show2DView();
      return;
    }

    // store AOI
    setLastAOIFromRect();

    // show 3D first
    show3DView();

    // update loader text while loading geojson
    showLoading("Loading 3D buildings‚Ä¶");

    // load buildings into mapbox
    loadBuildings(data.geojson);
    apply3DStyleMode();
    showExportPanel(data);

    // tiles debug
    if (data.tiles && data.tiles.length > 0) drawTiles(data.tiles);
    else tileDebugLayer.clearLayers();

    // ‚úÖ Wait until mapbox finishes rendering the new source/layers
    map3d.once("idle", () => {
      if (lastAOIBounds) flyToAOI(lastAOIBounds);
      hideLoading(); // ‚úÖ enable interactions only when fully rendered
    });

  } catch (err) {
    console.error(err);
    hideLoading();
    alert("‚ùå Error running model. Check console/logs.");
  }
}


/* ================= BUILDINGS ================= */

map3d.on("load", () => {

  map3d.addSource("custom-tiles", {
    type: "raster",
    tiles: [
      "/tiles/{z}/{x}/{y}.png"
    ],
    tileSize: 256,
    maxzoom: 20
  });

  map3d.addLayer({
    id: "custom-tiles-layer",
    type: "raster",
    source: "custom-tiles",
    paint: {
      "raster-opacity": 1.0
    }
  });


  apply3DStyleMode();

});

let p2pLineFeatures = [];
let p2pLineHoverPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 10 });

function ensureP2PLineLayer() {
  if (map3d.getSource("p2p-lines")) return;

  map3d.addSource("p2p-lines", {
    type: "geojson",
    data: { type: "FeatureCollection", features: [] }
  });

  map3d.addLayer({
    id: "p2p-lines-layer",
    type: "line",
    source: "p2p-lines",
    paint: {
      "line-width": 4,
      "line-opacity": 0.85
    }
  });

  // map3d.on("mousemove", "p2p-lines-layer", (e) => {
  //   map3d.getCanvas().style.cursor = "pointer";
  //   const f = e.features && e.features[0];
  //   if (!f) return;

  //   const html = `<div class="p2p-label" style="min-width:120px;">
  //     <b>Segment ${f.properties.seg}</b>
  //     <div class="p2p-small">Distance: ${f.properties.dist}</div>
  //   </div>`;

  //   p2pLineHoverPopup.setLngLat(e.lngLat).setHTML(html).addTo(map3d);
  // });



  map3d.on("mouseleave", "p2p-lines-layer", () => {
    map3d.getCanvas().style.cursor = "";
    p2pLineHoverPopup.remove();
  });
}

function addMapboxLine(a, b, distanceMeters, segIndex) {
  ensureP2PLineLayer();

  const feature = {
    type: "Feature",
    geometry: { type: "LineString", coordinates: [a, b] },
    properties: { seg: segIndex, dist: formatMeters(distanceMeters) }
  };

  p2pLineFeatures.push(feature);

  const src = map3d.getSource("p2p-lines");
  if (src) {
    src.setData({ type: "FeatureCollection", features: p2pLineFeatures });
  }
}

function clearMapboxLines() {
  p2pLineFeatures = [];
  if (map3d.getSource("p2p-lines")) {
    map3d.getSource("p2p-lines").setData({ type: "FeatureCollection", features: [] });
  }
  try { p2pLineHoverPopup.remove(); } catch(e){}
}



function loadBuildings(path){
  if(map3d.getLayer("buildings")) map3d.removeLayer("buildings");
  if(map3d.getSource("buildings")) map3d.removeSource("buildings");

  //map3d.addSource("buildings",{ type:"geojson", data:"/ml/"+path });
  map3d.addSource("buildings", {
  type: "geojson",
  data: "/ml/" + path,
  generateId: true   // üîë REQUIRED
});




// 1Ô∏è‚É£ ADD BUILDINGS FIRST
// map3d.addLayer({
//   id:"buildings",
//   type:"fill-extrusion",
//   source:"buildings",
//   paint:{
//     "fill-extrusion-color": [
//       "interpolate",
//       ["linear"],
//       ["get", "confidence"],
//       0.4, "#FF3333",
//       0.7, "#FFA500",
//       0.9, "#00FF99"
//     ],
//     "fill-extrusion-height":["get","height"],
//     "fill-extrusion-opacity":0.85
//   }
// });

map3d.addLayer({
  id:"buildings",
  type:"fill-extrusion",
  source:"buildings",
  // üîë THIS LINE IS CRITICAL
  filter: ["==", ["get", "kind"], "building"],
  paint:{
    "fill-extrusion-color": [
      "case",

      // üîµ SELECTED (feedback click)
      ["boolean", ["feature-state", "selected"], false],
      "#00FFFF",

      // üü£ HOVER
      ["boolean", ["feature-state", "hover"], false],
      "#8000FF",

      // üåà DEFAULT: confidence-based
      [
        "interpolate",
        ["linear"],
        ["get", "confidence"],
        0.4, "#FF3333",
        0.7, "#FFA500",
        0.9, "#00FF99"
      ]
    ],
    "fill-extrusion-height":["get","height"],
    "fill-extrusion-opacity":0.85
  }
});

// 2Ô∏è‚É£ INSERT SHADOWS *BEFORE* BUILDINGS
map3d.addLayer(
  {
    id: "building-shadows",
    type: "fill",
    source: "buildings",
    paint: {
      "fill-color": "#111111",
      "fill-opacity": 0.35
    },
    filter: ["==", ["get", "kind"], "shadow"]
  },
  "buildings"
);


map3d.on("click", "buildings", e => {
  if (!feedbackMode) return;

  const type = document.querySelector(
    'input[name="fbType"]:checked'
  ).value;

  // ‚ùå Missing building must never use 3D click
  if(type === "missing_building"){
    alert("Missing building ‚Üí draw polygon in 2D");
    return;
  }

  const feature = e.features[0];
  selectedOriginalGeometry = feature.geometry;
  highlightedFeatureId = feature.id;


  // Reset highlight
  map3d.setPaintProperty("buildings", "fill-extrusion-color", "#00FFFF");

  map3d.setFeatureState(
    { source: "buildings", id: highlightedFeatureId },
    { selected: true }
  );

  // üî¥ NOT A BUILDING
  if (type === "not_a_building") {
    map3d.setPaintProperty("buildings", "fill-extrusion-color", [
      "case",
      ["boolean", ["feature-state", "selected"], false],
      "#FF3333",
      "#00FFFF"
    ]);

    new maplibregl.Popup()
      .setLngLat(e.lngLat)
      .setHTML("<b>Marked:</b> üö´ Not a Building")
      .addTo(map3d);

    alert("Marked as NOT A BUILDING.\nClick Submit to confirm.");
    return;
  }

  // ‚ùå WRONG GEOMETRY
  if (type === "wrong_geometry") {
    map3d.setPaintProperty("buildings", "fill-extrusion-color", [
      "case",
      ["boolean", ["feature-state", "selected"], false],
      "#FFA500", // üü† orange = wrong geometry
      "#00FFFF"
    ]);

    new maplibregl.Popup()
      .setLngLat(e.lngLat)
      .setHTML("<b>Wrong Geometry</b><br/>Redraw correct footprint in 2D")
      .addTo(map3d);

    // üîë SWITCH TO 2D FOR DRAWING
    show2DView();
    alert("Now redraw the correct footprint in 2D.");
    return;
  }

  // ‚õî Missing building should NOT use 3D click
  alert("Missing building: draw polygon in 2D.");
});





  modelLoaded = true;
}


/* ========= on hover building handler ========== */


// map3d.on("mousemove", "buildings", e => {
//   const f = e.features[0];
//   if (!f) return;

//   map3d.getCanvas().style.cursor = "pointer";

//   hoverPopup
//     .setLngLat(e.lngLat)
//     .setHTML(`
//       <div style="font-size:12px">
//         <b>${f.properties.id}</b><br/>
//         Height: ${Number(f.properties.height).toFixed(2)} m<br/>
//         Confidence: ${(f.properties.confidence * 100).toFixed(1)}%
//       </div>
//     `)
//     .addTo(map3d);
// });
map3d.on("mousemove", "buildings", e => {
  const f = e.features[0];
  if (!f) return;

  map3d.getCanvas().style.cursor = "pointer";

  // üîÅ Clear previous hover
  if (hoveredFeatureId !== null && hoveredFeatureId !== f.id) {
    map3d.setFeatureState(
      { source: "buildings", id: hoveredFeatureId },
      { hover: false }
    );
  }

  hoveredFeatureId = f.id;

  // üü£ Set hover on current feature
  map3d.setFeatureState(
    { source: "buildings", id: hoveredFeatureId },
    { hover: true }
  );

  hoverPopup
    .setLngLat(e.lngLat)
    .setHTML(`
      <div style="font-size:12px">
        <b>${f.properties.id}</b><br/>
        Height: ${Number(f.properties.height).toFixed(2)} m<br/>
        Confidence: ${(f.properties.confidence * 100).toFixed(1)}%
      </div>
    `)
    .addTo(map3d);
});


// map3d.on("mousemove", "building-shadows", e => {
//   const f = e.features[0];
//   if (!f) return;

//   map3d.getCanvas().style.cursor = "pointer";

//   hoverPopup
//     .setLngLat(e.lngLat)
//     .setHTML(`
//       <div style="font-size:12px;color:#111">
//         <b>Shadow of ${f.properties.parent_building}</b><br/>
//         Shadow length: ${Number(f.properties.shadow_length_m).toFixed(2)} m<br/>
//         Sun azimuth: ${Number(f.properties.sun_azimuth).toFixed(1)}¬∞<br/>
//         Confidence: ${(f.properties.confidence * 100).toFixed(0)}%
//       </div>
//     `)
//     .addTo(map3d);
// });


map3d.on("mousemove", "building-shadows", e => {
  const f = e.features && e.features[0];
  if (!f) return;

  // üîë HARD GUARD
  if (f.properties.kind !== "shadow") return;

  console.log("üü¢ SHADOW VALUES USED:", {
    parent_building: f.properties.parent_building,
    shadow_length_m: f.properties.shadow_length_m,
    sun_azimuth: f.properties.sun_azimuth,
    sun_elevation: f.properties.sun_elevation,
    confidence: f.properties.confidence
  });

  map3d.getCanvas().style.cursor = "pointer";

  hoverPopup
    .setLngLat(e.lngLat)
    .setHTML(`
      <div style="font-size:12px;color:#111">
        <b>Shadow of ${f.properties.parent_building}</b><br/>
        Shadow length: ${Number(f.properties.shadow_length_m).toFixed(2)} m<br/>
        Sun azimuth: ${Number(f.properties.sun_azimuth).toFixed(12)}¬∞<br/>
        Sun elevation: ${Number(f.properties.sun_elevation).toFixed(12)}¬∞<br/>
        Confidence: ${(f.properties.confidence * 100).toFixed(0)}%
      </div>
    `)
    .addTo(map3d);

});


// map3d.on("mouseleave", "buildings", () => {
//   map3d.getCanvas().style.cursor = "";
//   hoverPopup.remove();
// });

map3d.on("mouseleave", "buildings", () => {
  map3d.getCanvas().style.cursor = "";
  hoverPopup.remove();

  if (hoveredFeatureId !== null) {
    map3d.setFeatureState(
      { source: "buildings", id: hoveredFeatureId },
      { hover: false }
    );
    hoveredFeatureId = null;
  }
});


map3d.on("mouseleave", "building-shadows", () => {
   map3d.getCanvas().style.cursor = "";
  hoverPopup.remove();
});

/* satellite view */

function toggle3DStyle() {
  viewStyleMode = (viewStyleMode === "satellite") ? "shadowmap" : "satellite";
  apply3DStyleMode();
}

function apply3DStyleMode() {
  if (!map3d) return;

  // --- ids you already use ---
  const RASTER_LAYER_ID = "custom-tiles-layer";
  const BUILDINGS_LAYER_ID = "buildings";
  const SHADOWS_LAYER_ID = "building-shadows";
  const BG_LAYER_ID = "shadowmap-bg";

  const isShadow = (viewStyleMode === "shadowmap");

  // Ensure background layer exists (MapLibre supports "background" layer)
  try {
    if (!map3d.getLayer(BG_LAYER_ID)) {
      map3d.addLayer({
        id: BG_LAYER_ID,
        type: "background",
        paint: { "background-color": "#f6f0d6", "background-opacity": 1.0 }
      }, RASTER_LAYER_ID); // insert before raster if possible
    }
  } catch (e) {
    // if raster layer not yet added, background will be added later
    // safe to ignore
  }

  // Background on/off
  try {
    if (map3d.getLayer(BG_LAYER_ID)) {
      map3d.setLayoutProperty(BG_LAYER_ID, "visibility", isShadow ? "visible" : "none");
      map3d.setPaintProperty(BG_LAYER_ID, "background-color", "#f6f0d6");
      map3d.setPaintProperty(BG_LAYER_ID, "background-opacity", 1.0);
    }
  } catch(e){}

  // Raster tiles fade/disable
  try {
    if (map3d.getLayer(RASTER_LAYER_ID)) {
      map3d.setPaintProperty(RASTER_LAYER_ID, "raster-opacity", isShadow ? 0.12 : 1.0);
      map3d.setLayoutProperty(RASTER_LAYER_ID, "visibility", "visible"); // keep layer alive
    }
  } catch(e){}

  // Buildings color change
  try {
    if (map3d.getLayer(BUILDINGS_LAYER_ID)) {
      if (isShadow) {
        // Solid dark grey blocks (still respects hover/selected if you want)
        map3d.setPaintProperty(BUILDINGS_LAYER_ID, "fill-extrusion-color", [
          "case",
          ["boolean", ["feature-state", "selected"], false], "#00FFFF",
          ["boolean", ["feature-state", "hover"], false], "#8000FF",
          "#2f2f2f" // dark grey blocks
        ]);
        map3d.setPaintProperty(BUILDINGS_LAYER_ID, "fill-extrusion-opacity", 0.95);
      } else {
        // Restore your confidence-based colors
        map3d.setPaintProperty(BUILDINGS_LAYER_ID, "fill-extrusion-color", [
          "case",
          ["boolean", ["feature-state", "selected"], false], "#00FFFF",
          ["boolean", ["feature-state", "hover"], false], "#8000FF",
          ["interpolate", ["linear"], ["get", "confidence"],
            0.4, "#00FF99",
            0.7, "#00FF99",
            0.9, "#00FF99"
          ]
        ]);
        map3d.setPaintProperty(BUILDINGS_LAYER_ID, "fill-extrusion-opacity", 0.85);
      }
    }
  } catch(e){}

  // Optional: shadows layer visibility (up to you)
  try {
    if (map3d.getLayer(SHADOWS_LAYER_ID)) {
      map3d.setLayoutProperty(SHADOWS_LAYER_ID, "visibility", isShadow ? "none" : "visible");
    }
  } catch(e){}

  showToast(
    isShadow
      ? `<b>üü® Shadowmap view</b><div class="small">Buildings only (dark grey) on light background</div>`
      : `<b>üõ∞ Satellite view</b><div class="small">Raster tiles + normal building colors</div>`,
    2200
  );
}




/* P2P distance calculator */

/* ================= P2P + POINT INFO TOOLING ================= */

// ---------- Toast ----------
let toastTimer = null;
function showToast(html, ms = 2200) {
  const el = document.getElementById("toast");
  if (!el) return;
  el.innerHTML = html;
  el.style.display = "block";
  if (toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    el.style.display = "none";
  }, ms);
}

// ---------- Mode helpers ----------
function isAnyDrawingModeActive() {
  // If any of these are true, DO NOT show "point info" click popups
  return !!(feedbackMode || yoloMode || aoiDrawActive || p2pMode || manualBuildMode );
}

// ---------- Distance helpers ----------
function haversineMeters(aLngLat, bLngLat) {
  const toRad = (d) => d * Math.PI / 180.0;
  const R = 6371000.0; // meters
  const lat1 = toRad(aLngLat[1]);
  const lat2 = toRad(bLngLat[1]);
  const dLat = toRad(bLngLat[1] - aLngLat[1]);
  const dLon = toRad(bLngLat[0] - aLngLat[0]);

  const s1 = Math.sin(dLat / 2);
  const s2 = Math.sin(dLon / 2);
  const h = s1 * s1 + Math.cos(lat1) * Math.cos(lat2) * s2 * s2;
  return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
}

function formatMeters(m) {
  if (m >= 1000) return `${(m / 1000).toFixed(3)} km`;
  return `${m.toFixed(2)} m`;
}

function fmtCoord(x, digits = 6) {
  return Number(x).toFixed(digits);
}

// ---------- P2P state ----------
let p2pMode = false;
let p2pPair = [];              // current pair: [[lng,lat], [lng,lat]]
let p2pCount = 0;              // segment counter

// Keep ALL drawn stuff so we can clear on disable
let p2pLayers2D = [];          // Leaflet layers
let p2pMarkers3D = [];         // Mapbox Marker
let p2pPopups3D = [];          // Mapbox Popup

function setP2PButtonActive(active) {
  const btn = document.getElementById("p2pBtn");
  if (!btn) return;
  if (active) btn.classList.add("tool-active");
  else btn.classList.remove("tool-active");
}

function clearAllP2PGraphics() {
  // 2D
  try {
    p2pLayers2D.forEach(l => {
      try { map2d.removeLayer(l); } catch(e){}
    });
  } catch(e){}
  p2pLayers2D = [];

  // 3D
  try {
    p2pMarkers3D.forEach(m => { try { m.remove(); } catch(e){} });
  } catch(e){}
  p2pMarkers3D = [];

  try {
    p2pPopups3D.forEach(p => { try { p.remove(); } catch(e){} });
  } catch(e){}
  p2pPopups3D = [];
}

function toggleP2PDistance() {
  p2pMode = !p2pMode;

  if (p2pMode) {
    p2pPair = [];
    p2pCount = 0;
    setP2PButtonActive(true);
    showToast(`<b>üìè P2P Distance enabled</b><div class="small">Click any two points to measure. Keep clicking pairs to measure multiple distances. Click the button again to clear & disable.</div>`, 3500);
  } else {
    // Disable + clear everything
    p2pPair = [];
    p2pCount = 0;
    setP2PButtonActive(false);
    clearAllP2PGraphics();
    showToast(`<b>üìè P2P Distance disabled</b><div class="small">Cleared all measurements.</div>`, 2000);
  }
}


const P2P_DIRS = ["p2p-ne", "p2p-nw", "p2p-se", "p2p-sw"];

function oppositeDir(dir) {
  if (dir === "p2p-ne") return "p2p-sw";
  if (dir === "p2p-sw") return "p2p-ne";
  if (dir === "p2p-nw") return "p2p-se";
  return "p2p-nw"; // p2p-se -> p2p-nw
}

function p2pPointHtml(label, lng, lat) {
  return `
    <div class="p2p-badge">${label}</div>
    <div class="p2p-small">lat ${fmtCoord(lat)}<br/>lon ${fmtCoord(lng)}</div>
  `;
}

// ---------- Drawing helpers ----------
function addLeafletLabel(lat, lng, html, dirClass = "p2p-ne") {
  const m = L.marker([lat, lng], {
    interactive: false,
    icon: L.divIcon({
      className: "", // important: we control styling inside
      html: `<div class="p2p-label ${dirClass}">${html}</div>`
    })
  }).addTo(map2d);

  p2pLayers2D.push(m);
  return m;
}

function addLeafletDot(lat, lng) {
  const dot = L.circleMarker([lat, lng], { radius: 6, weight: 2, fillOpacity: 0.85 }).addTo(map2d);
  p2pLayers2D.push(dot);
  return dot;
}

function addLeafletLine(a, b, distanceMeters, segIndex) {
  const line = L.polyline([[a[1], a[0]], [b[1], b[0]]], { weight: 3 }).addTo(map2d);

  // Distance tooltip only on hover
  const html = `<div class="p2p-label" style="min-width:120px;">
    <b>Segment ${segIndex}</b><div class="p2p-small">Distance: ${formatMeters(distanceMeters)}</div>
  </div>`;

  line.bindTooltip(html, {
    sticky: true,
    direction: "top",
    opacity: 0.98
  });

  p2pLayers2D.push(line);
  return line;
}


function addMapboxLabel(lng, lat, html) {
  const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 12 })
    .setLngLat([lng, lat])
    .setHTML(`<div style="
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      line-height: 1.2;
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
      white-space: nowrap;
    ">${html}</div>`)
    .addTo(map3d);

  p2pPopups3D.push(popup);
  return popup;
}

function addMapboxDot(lng, lat) {
  const el = document.createElement("div");
  el.style.width = "10px";
  el.style.height = "10px";
  el.style.borderRadius = "50%";
  el.style.border = "2px solid #fff";
  el.style.background = "#2563eb";
  const mk = new maplibregl.Marker({ element: el }).setLngLat([lng, lat]).addTo(map3d);
  p2pMarkers3D.push(mk);
  return mk;
}

// ---------- P2P click handler ----------
// COMPLETE: handleP2PClick
// - multiple segments
// - endpoint labels bigger + readable
// - A/B labels placed in opposite directions, rotated per segment to avoid overlap
// - distance shown ONLY on hover of the line (2D + 3D)
// - does NOT interfere with feedback/run-ml because callers already gate by modes

function handleP2PClick(lng, lat) {
  if (!p2pMode) return;

  // ensure state
  if (!Array.isArray(p2pPair)) p2pPair = [];
  if (p2pPair.length >= 2) p2pPair = [];

  // push click
  p2pPair.push([lng, lat]);

  const segIndex = p2pCount + 1;
  const baseDir = P2P_DIRS[p2pCount % P2P_DIRS.length];

  // --- FIRST CLICK: ONLY DOTS, NO LABELS ---
  if (p2pPair.length === 1) {
    addLeafletDot(lat, lng);
    addMapboxDot(lng, lat);
    return;
  }

  // --- SECOND CLICK: draw second dot + NOW show BOTH endpoint labels ---
  const a = p2pPair[0];
  const b = p2pPair[1];

  // dot for B
  addLeafletDot(b[1], b[0]);
  addMapboxDot(b[0], b[1]);

  // show labels for A and B (only now)
  const dirA = baseDir;
  const dirB = oppositeDir(baseDir);

  addLeafletLabel(a[1], a[0], p2pPointHtml(`Seg ${segIndex} ¬∑ A`, a[0], a[1]), dirA);
  addLeafletLabel(b[1], b[0], p2pPointHtml(`Seg ${segIndex} ¬∑ B`, b[0], b[1]), dirB);

  addMapboxLabel(a[0], a[1], p2pPointHtml(`Seg ${segIndex} ¬∑ A`, a[0], a[1]));
  addMapboxLabel(b[0], b[1], p2pPointHtml(`Seg ${segIndex} ¬∑ B`, b[0], b[1]));

  // distance + line hover tooltip logic unchanged
  const d = haversineMeters(a, b);

  addLeafletLine(a, b, d, segIndex);

  if (map3d && map3d.loaded()) {
    addMapboxLine(a, b, d, segIndex);
  }

  // finish segment
  p2pPair = [];
  p2pCount += 1;
}




// ---------- POINT INFO (single click when idle) ----------

// Keep track of the currently open point-info in 2D/3D (so we can close it)
let _activePointInfo = { leaflet: null, mapbox: null };

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    showToast(`<b>‚úÖ Copied</b><div class="small">${text}</div>`, 1400);
  } catch (e) {
    // fallback (works even without clipboard permission)
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    document.execCommand("copy");
    ta.remove();
    showToast(`<b>‚úÖ Copied</b><div class="small">${text}</div>`, 1400);
  }
}

function closePointInfo(source = "2d") {
  if (source === "2d") {
    try { if (_activePointInfo.leaflet) map2d.removeLayer(_activePointInfo.leaflet); } catch(e){}
    _activePointInfo.leaflet = null;
  } else {
    try { if (_activePointInfo.mapbox) _activePointInfo.mapbox.remove(); } catch(e){}
    _activePointInfo.mapbox = null;
  }
}

function showPointInfo(lng, lat, source = "2d") {
  const latS = fmtCoord(lat, 6);
  const lonS = fmtCoord(lng, 6);
  const clip = `${latS},${lonS}`;

  const html = `
    <div class="p2p-label pinfo-wrap">
      <button class="pinfo-close" title="Close" type="button">‚úï</button>

      <b>üìç Point</b>
      <div class="p2p-small">lat ${latS}<br/>lon ${lonS}</div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button class="pinfo-copy" type="button"
          style="
            cursor:pointer;
            border:1px solid rgba(0,0,0,0.20);
            background:#fff;
            border-radius:8px;
            padding:6px 10px;
            font-size:12px;
          "
        >üìã Copy</button>

        <span class="p2p-small" style="opacity:0.75;">${clip}</span>
      </div>
    </div>
  `;

  if (source === "2d") {
    // close previous 2D popup (so you don't stack)
    closePointInfo("2d");

    const m = L.marker([lat, lng], {
      interactive: true,
      icon: L.divIcon({ className: "", html })
    }).addTo(map2d);

    _activePointInfo.leaflet = m;

    // IMPORTANT: stop propagation ONLY on this popup element
    setTimeout(() => {
      const el = m.getElement();
      if (!el) return;

      // prevent Leaflet map click firing when clicking inside popup
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);

      // also stop mousedown/touchstart (prevents map drag/pan starting)
      L.DomEvent.on(el, "mousedown touchstart dblclick", L.DomEvent.stopPropagation);

      // wire buttons
      const btnCopy = el.querySelector(".pinfo-copy");
      const btnClose = el.querySelector(".pinfo-close");

      if (btnCopy) {
        btnCopy.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          copyToClipboard(clip);
        });
      }

      if (btnClose) {
        btnClose.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          closePointInfo("2d");
        });
      }
    }, 0);

    // auto-close after some time (optional)
    setTimeout(() => closePointInfo("2d"), 9000);

  } else {
    // close previous 3D popup
    closePointInfo("3d");

    const pop = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 12 })
      .setLngLat([lng, lat])
      .setHTML(html)
      .addTo(map3d);

    _activePointInfo.mapbox = pop;

    setTimeout(() => {
      const el = pop.getElement();
      if (!el) return;

      // stop mapbox click bubbling
      el.addEventListener("click", (ev) => ev.stopPropagation());
      el.addEventListener("mousedown", (ev) => ev.stopPropagation());
      el.addEventListener("touchstart", (ev) => ev.stopPropagation());

      const btnCopy = el.querySelector(".pinfo-copy");
      const btnClose = el.querySelector(".pinfo-close");

      if (btnCopy) {
        btnCopy.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          copyToClipboard(clip);
        });
      }

      if (btnClose) {
        btnClose.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          closePointInfo("3d");
        });
      }
    }, 0);

    setTimeout(() => closePointInfo("3d"), 9000);
  }
}




// ---------- Hook 2D click (DO NOT break other handlers) ----------
map2d.on("click", (e) => {
  // If P2P is on, it should capture idle clicks (but still not interfere with feedback/yolo/aoi)
  if (p2pMode) {
    handleP2PClick(e.latlng.lng, e.latlng.lat);
    return;
  }

  // If nothing else is active, show point info
  if (!isAnyDrawingModeActive()) {
    showPointInfo(e.latlng.lng, e.latlng.lat, "2d");
  }
});

// ---------- Hook 3D click (general map click) ----------
map3d.on("click", (e) => {
  // If P2P is on, capture (but not if feedbackMode etc is active)
  if (p2pMode) {
    handleP2PClick(e.lngLat.lng, e.lngLat.lat);
    return;
  }

  // Only show point info when truly idle
  if (!isAnyDrawingModeActive()) {
    showPointInfo(e.lngLat.lng, e.lngLat.lat, "3d");
  }
});

// Also: if user hits Clear, ensure p2p button resets visually
// (Your clearAll already disables p2p; just add this line inside clearAll after p2pMode=false)



/* ================= FEEDBACK ================= */






function enableFeedbackMode(){
  feedbackMode = true;
  feedbackPoints = [];
  feedbackPolygons = [];
  selectedOriginalGeometry = null;
  feedbackLayer.clearLayers();
  updatePolyCount();
setAddPolyEnabled(false);
  document.getElementById("feedbackPanel").style.display="block";

  if(highlightedFeatureId !== null){
  map3d.setFeatureState(
    { source:"buildings", id: highlightedFeatureId },
    { selected:false }
  );
  highlightedFeatureId = null;
}

}



// map2d.on("click", e=>{
//   if (yoloMode) return;   // üîë ADD THIS LINE
//   if (!feedbackMode) return;

//   const type = document.querySelector('input[name="fbType"]:checked').value;

//   if(type==="wrong_geometry" && !selectedOriginalGeometry){
//     alert("Click the wrong building in 3D first");
//     return;
//   }

//   feedbackPoints.push([e.latlng.lng, e.latlng.lat]);
//   feedbackLayer.clearLayers();

//   if(feedbackPoints.length>2){
//     const poly = [...feedbackPoints, feedbackPoints[0]];
//     L.polygon(poly.map(p=>[p[1],p[0]]),
//       {color:"red",fillOpacity:0.3}
//     ).addTo(feedbackLayer);
//   } else {
//     L.circleMarker(e.latlng,{radius:5,color:"red"}).addTo(feedbackLayer);
//   }
// });


map2d.on("click", e=>{
  if (yoloMode) return;
  if (!feedbackMode) return;

  const type = document.querySelector('input[name="fbType"]:checked').value;

  if(type==="wrong_geometry" && !selectedOriginalGeometry){
    alert("Click the wrong building in 3D first");
    return;
  }

  feedbackPoints.push([e.latlng.lng, e.latlng.lat]);
  //feedbackLayer.clearLayers();

   if (feedbackPoints.length < 3) {
    L.circleMarker(e.latlng, { radius: 5, color: "orange" }).addTo(feedbackLayer);
    setAddPolyEnabled(false);
    return;
  }

  // Once we hit 3 points, auto-close preview polygon & enable button
  redrawCurrentPolygonPreview();
  setAddPolyEnabled(true);
});


map2d.on("click", e => {
  if (!yoloMode) return;


  yoloPoints.push([e.latlng.lng, e.latlng.lat]);

  // visual marker
  L.circleMarker(e.latlng, {
    radius: 5,
    color: "deepskyblue"
  }).addTo(feedbackLayer);

  // auto-close at 3 points
  redrawYOLOPreview();
});


// Helper: GeoJSON Polygon -> [minLng, minLat, maxLng, maxLat]
function geomToBbox(geom) {
  // geom: GeoJSON Polygon
  const coords = geom.coordinates[0];
  let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

  coords.forEach(([lng, lat]) => {
    minLng = Math.min(minLng, lng);
    minLat = Math.min(minLat, lat);
    maxLng = Math.max(maxLng, lng);
    maxLat = Math.max(maxLat, lat);
  });

  return [minLng, minLat, maxLng, maxLat];
}

// Helper: GeoJSON Polygon or MultiPolygon -> bbox
function anyGeomToBbox(geom) {
  // supports Polygon or MultiPolygon
  let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

  function consumeRing(ring) {
    ring.forEach(([lng, lat]) => {
      minLng = Math.min(minLng, lng);
      minLat = Math.min(minLat, lat);
      maxLng = Math.max(maxLng, lng);
      maxLat = Math.max(maxLat, lat);
    });
  }

  if (!geom || !geom.type) return null;

  if (geom.type === "Polygon") {
    consumeRing(geom.coordinates[0]);
  } else if (geom.type === "MultiPolygon") {
    geom.coordinates.forEach(poly => {
      // poly is array of rings; take exterior ring [0]
      if (poly && poly[0]) consumeRing(poly[0]);
    });
  } else {
    return null;
  }

  if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) {
    return null;
  }
  return [minLng, minLat, maxLng, maxLat];
}

async function submitFeedback() {
  const type = document.querySelector('input[name="fbType"]:checked').value;

  const payload = { type };

  // Always attach AOI bounds if available (helps backend convert to pixels)
  if (aoiRect) {
    const bb = aoiRect.getBounds();
    payload.aoi_bounds = [bb.getWest(), bb.getSouth(), bb.getEast(), bb.getNorth()];
  }

  // Attach selected feature id if available (useful debugging / linking)
  if (typeof highlightedFeatureId !== "undefined" && highlightedFeatureId !== null) {
    payload.original_feature_id = highlightedFeatureId;
  }

  // -----------------------------
  // CLICK-BASED: NOT A BUILDING
  // -----------------------------
  if (type === "not_a_building") {
    if (!selectedOriginalGeometry) {
      alert("Click the wrong object in 3D first");
      return;
    }

    payload.original_geometry = selectedOriginalGeometry;

    // box prompt for negatives (optional)
    const ob = anyGeomToBbox(selectedOriginalGeometry);
    if (ob) payload.original_bbox = ob;
  }

  // -----------------------------
  // DRAW-BASED: MISSING / WRONG
  // -----------------------------
    // -----------------------------
  // DRAW-BASED: MISSING / WRONG
  // -----------------------------
  else {

    // ‚úÖ WRONG GEOMETRY (multi polygon) handled FIRST
    if (type === "wrong_geometry") {

      // auto-finalize current polygon if ready (user didn't press add)
      const cur = getCurrentDrawnPolygonIfReady();
      if (cur) {
        feedbackPolygons.push(cur);
        updatePolyCount();
        feedbackPoints = [];
      }

      if (feedbackPolygons.length === 0) {
        alert("Draw at least one corrected polygon (3 points).");
        return;
      }

      if (!selectedOriginalGeometry) {
        alert("Click the wrong building in 3D first");
        return;
      }

      payload.correct_geometries = feedbackPolygons;
      payload.original_geometry = selectedOriginalGeometry;

      const ob = anyGeomToBbox(selectedOriginalGeometry);
      if (ob) payload.original_bbox = ob;

    } else {
      // ‚úÖ Missing building (single polygon)
      if (feedbackPoints.length < 3) {
        alert("Select at least 3 points");
        return;
      }

      payload.geometry = {
        type: "Polygon",
        coordinates: [[...feedbackPoints, feedbackPoints[0]]]
      };

      payload.bbox = geomToBbox(payload.geometry);

      // Validate bbox
      if (payload.bbox) {
        const [minLng, minLat, maxLng, maxLat] = payload.bbox;
        if (!(maxLng > minLng && maxLat > minLat)) {
          alert("Invalid bbox, please redraw.");
          return;
        }
      }
    }
  }

  await fetch("/feedback", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });

  alert("‚úÖ Feedback saved");

  // Special: keep feedback mode for wrong_geometry loop
  if (type === "wrong_geometry") {
    resetPolygonState();

    if (highlightedFeatureId !== null) {
      map3d.setFeatureState(
        { source: "buildings", id: highlightedFeatureId },
        { selected: false }
      );
      highlightedFeatureId = null;
    }

    selectedOriginalGeometry = null;
    alert("Saved. Click another building in 3D to continue fixing geometry.");
    show3DView();
    return;
  }

  cancelFeedback();
}






function cancelFeedback(){
  feedbackMode = false;
  feedbackPoints = [];
  selectedOriginalGeometry = null;

  feedbackPolygons = [];
currentPolygonLayer = null;
updatePolyCount();
setAddPolyEnabled(false);

  if(highlightedFeatureId !== null){
    map3d.setFeatureState(
      { source: "buildings", id: highlightedFeatureId },
      { selected: false }
    );
    highlightedFeatureId = null;
  }

  feedbackLayer.clearLayers();
  document.getElementById("feedbackPanel").style.display = "none";
}



 /// yolo feedback


function enableYOLOFeedback() {
  if (currentRotation !== 0) {
    alert("Map rotation will be reset for YOLO annotation.");
    resetRotation();
  }

  if (!aoiRect) {
    alert("Draw AOI first");
    return;
  }

  yoloMode = true;
  yoloPoints = [];
  yoloPreviewLayer = null;

  feedbackLayer.clearLayers();
  clearAllDrawControls();
  show2DView();

  document.getElementById("yoloPanel").style.display = "block";
  document.getElementById("feedbackPanel").style.display = "none";

  alert("Click to draw roof polygon.\nMinimum 3 points required.");
}



// function enableYOLOFeedback() {
//   if (currentRotation !== 0) {
//     alert("Map rotation will be reset for YOLO annotation.");
//     resetRotation();
//   }

//   if (!aoiRect) {
//     alert("Draw AOI first");
//     return;
//   }

//   yoloMode = true;
//   yoloRectLayer = null;
//   feedbackLayer.clearLayers();

//   clearAllDrawControls();
//   show2DView();

//   const yoloRectDrawer = new L.Draw.Rectangle(map2d, {
//     shapeOptions: { color: "blue", fillOpacity: 0.25, weight: 2 }
//   });
//   yoloRectDrawer.enable();

//   document.getElementById("yoloPanel").style.display = "block";
//   document.getElementById("feedbackPanel").style.display = "none";

//   setTimeout(() => {
//     alert("Draw a bounding box (rectangle). Release mouse to finish.");
//   }, 100);
// }




// async function submitYOLOFeedback() {
//   if (!yoloRectLayer) {
//     alert("Draw a rectangle first");
//     return;
//   }

//   const type = document.querySelector('input[name="yoloType"]:checked').value;

//   const b = yoloRectLayer.getBounds();
//   const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()]; // [minLng,minLat,maxLng,maxLat]

//   // Optional: ensure inside AOI
//   if (aoiRect && !aoiRect.getBounds().contains(b)) {
//     alert("YOLO box must be fully inside AOI");
//     return;
//   }

//   const payload = {
//     type,
//     bbox,
//     aoi_bounds: [
//       aoiRect.getBounds().getWest(),
//       aoiRect.getBounds().getSouth(),
//       aoiRect.getBounds().getEast(),
//       aoiRect.getBounds().getNorth()
//     ]
//   };

//   await fetch("/feedback_yolo", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify(payload)
//   });

//   alert("‚úÖ YOLO feedback saved");
//   cancelYOLOFeedback();
// }

async function submitYOLOFeedback() {
  if (!yoloMode || yoloPoints.length < 3) {
    alert("Polygon must have at least 3 points");
    return;
  }

  const type = document.querySelector(
    'input[name="yoloType"]:checked'
  ).value;

  const geometry = {
    type: "Polygon",
    coordinates: [[...yoloPoints, yoloPoints[0]]] // auto-close
  };

  // Optional AOI containment check
  if (aoiRect && yoloPreviewLayer) {
    if (!aoiRect.getBounds().contains(yoloPreviewLayer.getBounds())) {
      alert("YOLO polygon must be fully inside AOI");
      return;
    }
  }

  const payload = {
    type,
    geometry,
    aoi_bounds: [
      aoiRect.getBounds().getWest(),
      aoiRect.getBounds().getSouth(),
      aoiRect.getBounds().getEast(),
      aoiRect.getBounds().getNorth()
    ]
  };

  await fetch("/feedback_yolo", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });

  alert("‚úÖ YOLO feedback saved");
  cancelYOLOFeedback();
}




function cancelYOLOFeedback() {
  yoloMode = false;
  yoloPoints = [];
  yoloPreviewLayer = null;

  feedbackLayer.clearLayers();
  document.getElementById("yoloPanel").style.display = "none";

  show2DView();
}




/* ================= RESET ================= */

// function clearAll(){

//   p2pMode = false;
//   p2pPair = [];
//   p2pCount = 0;
//   setP2PButtonActive(false);
//   clearAllP2PGraphics();



//   aoiLayer.clearLayers();
//   feedbackLayer.clearLayers();
//   aoiRect=null;
//   modelLoaded=false;
//   feedbackMode=false;
//   aoiDrawActive=false;
//   document.getElementById("aoiInfo").innerHTML="AOI: not selected";
//   hideExportPanel();
// }

function clearAll(){

  // --- stop p2p ---
  p2pMode = false;
  p2pPair = [];
  p2pCount = 0;
  setP2PButtonActive(false);
  clearAllP2PGraphics();
  try { clearMapboxLines(); } catch(e){}

  // --- close point info popups (2d + 3d) ---
  try { closePointInfo("2d"); } catch(e){}
  try { closePointInfo("3d"); } catch(e){}

  // --- reset AOI + feedback ---
  aoiLayer.clearLayers();
  feedbackLayer.clearLayers();
  tileDebugLayer.clearLayers();

  aoiRect = null;
  lastAOIBounds = null;

  feedbackMode = false;
  yoloMode = false;
  aoiDrawActive = false;

  feedbackPoints = [];
  yoloPoints = [];
  selectedOriginalGeometry = null;
  highlightedFeatureId = null;

  document.getElementById("aoiInfo").innerHTML = "AOI: not selected";
  hideExportPanel();

  // --- REMOVE buildings + shadows layers from mapbox ---
  try {
    if (map3d.getLayer("building-shadows")) map3d.removeLayer("building-shadows");
    if (map3d.getLayer("buildings")) map3d.removeLayer("buildings");
    if (map3d.getSource("buildings")) map3d.removeSource("buildings");
  } catch(e){}

  // --- also remove p2p line layer from mapbox ---
  try {
    if (map3d.getLayer("p2p-lines-layer")) map3d.removeLayer("p2p-lines-layer");
    if (map3d.getSource("p2p-lines")) map3d.removeSource("p2p-lines");
  } catch(e){}

  // --- IMPORTANT: restore map interactions (both maps) ---
  try { enableMapInteraction(map2d); } catch(e){}
  try { enableMapboxInteraction(map3d); } catch(e){}

  // --- reset view state ---
  modelLoaded = false;
  viewMode = "3d";  // default for next run

  // --- ALWAYS go back to 2D after clear ---
  show2DView();
}


// Show/hide "Add polygon" UI based on selected feedback type
document.querySelectorAll('input[name="fbType"]').forEach(r => {
  r.addEventListener("change", () => {
    const t = document.querySelector('input[name="fbType"]:checked').value;
    const btn = document.getElementById("addPolyBtn");
    const cnt = document.getElementById("polyCount");
    const show = (t === "wrong_geometry");
    if (btn) btn.style.display = show ? "block" : "none";
    if (cnt) cnt.style.display = show ? "block" : "none";

    // optional: also disable button when switching types
    if (!show && btn) btn.disabled = true;
  });
});

// Run once on page load to set correct initial visibility
(() => {
  const t = document.querySelector('input[name="fbType"]:checked')?.value;
  const btn = document.getElementById("addPolyBtn");
  const cnt = document.getElementById("polyCount");
  const show = (t === "wrong_geometry");
  if (btn) btn.style.display = show ? "block" : "none";
  if (cnt) cnt.style.display = show ? "block" : "none";
})();


function unloadPrebuildLayers() {
  // remove layers first
  if (map3d.getLayer("building-shadows")) {
    map3d.removeLayer("building-shadows");
  }

  if (map3d.getLayer("buildings")) {
    map3d.removeLayer("buildings");
  }

  // then remove source
  if (map3d.getSource("buildings")) {
    map3d.removeSource("buildings");
  }
}

async function togglePrebuildAll() {

  // ---------- TURN OFF PREBUILD ----------
  if (prebuildActive) {
  prebuildActive = false;

  unloadPrebuildLayers();   // üîë correct cleanup

  show2DView();
  modelLoaded = false;

  showToast(
    `<b>üó∫ Normal 2D map</b><div class="small">Prebuild view disabled</div>`,
    1800
  );

  return;
}

  // ---------- TURN ON PREBUILD ----------
  try {
    showLoading("Loading prebuilt 3D map‚Ä¶");

    const res = await fetch("/manual_build/prebuild/all");
    const data = await res.json();

    if (!data.exists) {
      hideLoading();
      showToast(
        `<b>‚ö† No prebuild available</b><div class="small">Save a manual build first</div>`,
        2600
      );
      return;
    }

    show3DView();
    // üîë ensure no stale source exists
    unloadPrebuildLayers();
    loadBuildings(data.geojson);
    apply3DStyleMode();

    map3d.once("idle", () => {
      hideLoading();
      prebuildActive = true;
      prebuildLoadedOnce = true;
      modelLoaded = true;

      showToast(
        `<b>üèô Prebuilt 3D map</b><div class="small">${data.runs} runs merged</div>`,
        2200
      );
    });

  } catch (e) {
    hideLoading();
    console.error(e);
    showToast(`<b>‚ùå Failed to load prebuild</b>`, 2000);
  }
}

function exportPrebuild(fmt) {
  if (!prebuildActive) {
    showToast(
      `<b>‚ö† Prebuild not active</b><div class="small">Enable Prebuild View first</div>`,
      2200
    );
    return;
  }

  const url = `/manual_build/prebuild/export/${fmt}`;
  window.open(url, "_blank");
}

async function togglePrebuildView() {
  const res = await fetch("/manual_build/prebuild/all");
  const data = await res.json();

  if (!data.exists) {
    showToast("‚ùå No prebuilt map available");
    return;
  }

  show3DView();
  loadBuildings(data.geojson);
  apply3DStyleMode();
}



window.addEventListener("load", async () => {
  try {
    const res = await fetch("/manual_build/prebuild/all");
    const data = await res.json();

    if (!data.exists) return;

    // Load like ML output (same pipeline)
    show3DView();
    showLoading("Loading prebuilt 3D map‚Ä¶");

    loadBuildings(data.geojson);   // existing function
    apply3DStyleMode();

    map3d.once("idle", () => {
      hideLoading();
      showToast("<b>üß± Prebuilt map loaded</b>", 1800);
    });

  } catch (e) {
    console.warn("No prebuild map found");
  }
});


</script>

<button onclick="togglePrebuildAll()" style="position:absolute; bottom:12px; left:12px; z-index:9999;">
üß± Prebuild View
</button>

</body>
</html>
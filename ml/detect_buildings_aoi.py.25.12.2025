# ml/detect_buildings_aoi.py

import os
import logging
import cv2
import numpy as np
import rasterio
import geopandas as gpd
import torch
import osmnx as ox
import math

from shapely.geometry import Polygon
from rasterio.warp import transform_bounds
from datetime import datetime, timezone
from astral.sun import elevation, azimuth
from astral import LocationInfo
from segment_anything import sam_model_registry, SamAutomaticMaskGenerator

from ml.roof_geometry import flat_roof
from ml.glb_export import export_glb

# --------------------------------------------------
# LOGGING
# --------------------------------------------------
logging.basicConfig(level=logging.INFO)

# --------------------------------------------------
# CONFIG
# --------------------------------------------------
BASE_TIF = "data/processed/merged_rgb_3857.tif"
AOI_TIF = "ml/aoi.tif"

OUT_DIR = "ml/output"
OUT_GEOJSON = f"{OUT_DIR}/buildings.geojson"
OUT_GLB = f"{OUT_DIR}/aoi_buildings.glb"

DEFAULT_HEIGHT = 12.0
MIN_AREA_PX = 600        # slightly higher for airports
MAX_AOI_RATIO = 0.08     # reject giant flat regions

IMAGE_ACQ_TIME = "2023-08-01T06:48:46.620"

os.makedirs(OUT_DIR, exist_ok=True)

# --------------------------------------------------
# DEVICE
# --------------------------------------------------
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
logging.info("Using device: %s", device)

# --------------------------------------------------
# LOAD SAM
# --------------------------------------------------
sam = sam_model_registry["vit_b"](checkpoint="ml/checkpoints/sam_vit_b.pth")
sam.to(device=device, dtype=torch.float32)
sam.eval()

decoder_ckpt = "ml/sam_training/checkpoints/sam_decoder_finetuned.pth.epoch8.pth"
sam.mask_decoder.load_state_dict(torch.load(decoder_ckpt, map_location=device))
logging.info("Fine-tuned SAM decoder loaded")

mask_generator = SamAutomaticMaskGenerator(
    sam,
    points_per_side=32,
    pred_iou_thresh=0.85,
    stability_score_thresh=0.90,
    crop_n_layers=1
)

# --------------------------------------------------
# OSM SETTINGS
# --------------------------------------------------
ox.settings.use_cache = True
ox.settings.cache_folder = "osm_cache"
ox.settings.log_console = False

# --------------------------------------------------
# HELPERS
# --------------------------------------------------
def extract_aoi(bounds):
    with rasterio.open(BASE_TIF) as src:
        bounds_3857 = transform_bounds("EPSG:4326", src.crs, *bounds)
        window = rasterio.windows.from_bounds(*bounds_3857, transform=src.transform)
        data = src.read([1, 2, 3], window=window)
        transform = src.window_transform(window)

        meta = src.meta.copy()
        meta.update({"height": data.shape[1], "width": data.shape[2]})

        with rasterio.open(AOI_TIF, "w", **meta) as dst:
            dst.write(data)

    return transform, src.crs

def texture_variance(img_rgb, poly, transform):
    mask = np.zeros(img_rgb.shape[:2], dtype=np.uint8)

    pts = [
        rasterio.transform.rowcol(transform, x, y)
        for x, y in poly.exterior.coords
    ]

    cv2.fillPoly(mask, [np.array(pts)], 255)

    gray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)
    values = gray[mask == 255]

    if len(values) < 50:
        return 0

    return np.std(values)


def overlaps_existing(poly, existing, thresh=0.5):
    for p, _ in existing:
        if poly.intersection(p).area / poly.area > thresh:
            return True
    return False


def get_osm_buildings(bounds):
    """
    bounds = [west, south, east, north] in EPSG:4326
    Compatible with OSMnx >= 2.0
    """
    #return None ## now, training sam only
    west, south, east, north = bounds

    try:
        gdf = ox.features_from_bbox(
            bbox=(west, south, east, north),
            tags={"building": True}
        )
    except TypeError:
        gdf = ox.features_from_bbox(
            north, south, east, west,
            tags={"building": True}
        )

    except Exception as e:
        logging.warning("OSM failed: %s", e)
        return None

    if gdf is None or gdf.empty:
        return None

    gdf = gdf[gdf.geometry.type.isin(["Polygon", "MultiPolygon"])]
    return gdf



def mask_to_polygon(mask, transform):
    seg = (mask["segmentation"] * 255).astype(np.uint8)
    cnts, _ = cv2.findContours(seg, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return None

    cnt = max(cnts, key=cv2.contourArea)
    if cv2.contourArea(cnt) < MIN_AREA_PX:
        return None

    coords = [
        rasterio.transform.xy(transform, int(p[0][1]), int(p[0][0]))
        for p in cnt
    ]
    poly = Polygon(coords)
    return poly if poly.is_valid else None


def is_airport_building(poly):
    hull = poly.convex_hull
    solidity = poly.area / max(hull.area, 1e-6)

    minx, miny, maxx, maxy = poly.bounds
    w = maxx - minx
    h = maxy - miny
    aspect = max(w, h) / max(1e-6, min(w, h))

    # ðŸ›‘ Runway / apron rejection
    if solidity < 0.25:
        return False
    if aspect > 20.0:
        return False

    return True

# --------------------------------------------------
# MAIN PIPELINE
# --------------------------------------------------
def detect_buildings(bounds):
    transform, raster_crs = extract_aoi(bounds)

    with rasterio.open(AOI_TIF) as src:
        img = src.read().transpose(1, 2, 0)

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    AOI_AREA = img_rgb.shape[0] * img_rgb.shape[1]

    buildings = []

    # ---------------- OSM FIRST ----------------
    osm = get_osm_buildings(bounds)
    if osm is not None:
        logging.info("Using OSM footprints")

        # for geom in osm.geometry:
        #     poly = (
        #         gpd.GeoSeries([geom], crs="EPSG:4326")
        #         .to_crs(raster_crs)
        #         .iloc[0]
        #     )
        #     buildings.append((poly, DEFAULT_HEIGHT))

        for geom in osm.geometry:
            if geom.geom_type == "MultiPolygon":
                geom = max(geom.geoms, key=lambda g: g.area)

            poly = (
                gpd.GeoSeries([geom], crs="EPSG:4326")
                .to_crs(raster_crs)
                .iloc[0]
            )

            if not is_airport_building(poly):
                continue

            buildings.append((poly, DEFAULT_HEIGHT))


    else:
        logging.info("OSM unavailable â†’ SAM fallback")

        masks = mask_generator.generate(img_rgb)

        for m in masks:
            if m["area"] < MIN_AREA_PX:
                continue
            if m["area"] > MAX_AOI_RATIO * AOI_AREA:
                continue

            if m.get("predicted_iou", 0) < 0.85:
                continue

            if m["segmentation"].mean() < 0.015:
                continue

            poly = mask_to_polygon(m, transform)
            if poly is None:
                continue

            if not is_airport_building(poly):
                continue

            tex_var = texture_variance(img_rgb, poly, transform)

            if overlaps_existing(poly, buildings):
                continue


            # ðŸš« Reject flat surfaces (runway/apron/grass)
            area_m2 = poly.area

            # Large roofs tolerate lower texture
            if area_m2 > 2000:
                if tex_var < 4.5:
                    continue
            else:
                if tex_var < 7.0:
                    continue




            buildings.append((poly, DEFAULT_HEIGHT))

            logging.info(
                "SAM OK | area=%d iou=%.2f seg=%.3f tex=%.1f",
                m["area"],
                m.get("predicted_iou", 0),
                m["segmentation"].mean(),
                tex_var
            )


    if not buildings:
        logging.warning("No buildings detected")
        return None

    polys, heights = zip(*buildings)

    gdf = gpd.GeoDataFrame(
        {"height": heights, "base": [0]*len(heights)},
        geometry=list(polys),
        crs=raster_crs
    ).to_crs(epsg=4326)

    gdf.to_file(OUT_GEOJSON, driver="GeoJSON")
    export_glb([flat_roof(p, h) for p, h in buildings], OUT_GLB)

    return {
        "geojson": "output/buildings.geojson",
        "glb": "output/aoi_buildings.glb"
    }
